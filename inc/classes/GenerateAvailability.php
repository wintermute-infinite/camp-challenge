<?php

class GenerateAvailability {
// Typehinting on the reservations and gapRules objects makes it so we don't need to include direct file references to class files
    public function generateAvailableCampsiteIds( Reservations $reservationsObj, $campsiteIds, $searchStartDate, $searchEndDate, GapRules $gapRulesObj ) {

// If reservations are empty, all campsiteIds are returned as matches
        if ( empty($reservationsObj) ) { return $campsiteIds; }
// Initialize in preparation for loop structures for data persistence
        $availCampsiteIds = $campsiteIds;
        $notAvailCampsiteIds = [];
// Uses GapRules class method to generate an array of existing gap rules + 1 to each value in order to convert for DatTime obj comparison
        $gapRuleArray = $gapRulesObj->convertGapRulesToArray();
// Gets the array format of the reservations
        $reservations = $reservationsObj->getReservations();
// Using the foreach loop allows us to iterate over each reservation and compare it to the search and GapRules data, building an array of matches throughout the process
        foreach ($reservations as $reservation) {

// Convert string dates into PHP DateTime objects in order to use the DateDiff function which requires DateTime objects as arguments

            $resStartDate = $reservationsObj->getReservationsStartDate($reservation);
            $resEndDate = $reservationsObj->getReservationsEndDate($reservation);

// Perform dateDiff function to determine the number of days between each date and store in vars. ->d is the flag to calculate the diff in days
            $searchStartDateDiff = (date_diff($searchStartDate, $resEndDate, TRUE))->d;
            $searchEndDateDiff = (date_diff($searchEndDate, $resStartDate, TRUE))->d;
// Initializes bool var for following if statement
            $gapRuleViolation = false;
// If not empty condition makes sure that only non-zero arrays of gap rules are passed to the method for processing
            if (!empty($gapRuleArray)) {
// Returns true if the gaprules array matches any set condition in the method body. This should make the addition of future rules more manageable
                $gapRuleViolation = $this->calculateGapRuleViolations($searchStartDateDiff, $searchEndDateDiff, $gapRuleArray);
            }
// Primary conditional that registers overlapping dates or gapRule violations in a persistent array
            if ((($searchStartDate == $resStartDate) || ($searchEndDate == $resEndDate)) || ($searchStartDate <= $resEndDate) && ($searchEndDate >= $resStartDate) || $gapRuleViolation) {
                $notAvailCampsiteIds[] = $reservation->campsiteId;
                continue;
            }
//  Evaluates to true only if this reservation has not violated any of our matching rules, storing positive matches in persistent array
            elseif( (!in_array($reservation->campsiteId, $availCampsiteIds))) {
                $availCampsiteIds[] = $reservation->campsiteId;
                continue;
            }
        }
// Composite array generated by removing negative matches from positive. I chose to have two separate arrays instead of one subtracting negative matches because this allowed better data persistence and the ability to quickly remove duplicate matches
        $generatedAvailableCampsiteIds = array_values(array_diff($availCampsiteIds, $notAvailCampsiteIds));

        return $generatedAvailableCampsiteIds;
    }
// Method called above for determining whether the current reservation is rejected due to violating a current Gap Rule
    private function calculateGapRuleViolations($searchStartDateDiff, $searchEndDateDiff, $gapRuleArray) {
// For single item arrays
        if (($searchStartDateDiff == $gapRuleArray[0]["gapSize"]) || ($searchEndDateDiff == $gapRuleArray[0]["gapSize"])) {
            return true;
        }
        elseif (count($gapRuleArray) > 1) {
// For arrays with 2 rules. I really wanted to add additional conditions and refactoring in order to handle 2+ arrays, so lets call this a beta
            if (($searchStartDateDiff >= $gapRuleArray[0]["gapSize"] && $searchStartDateDiff <= $gapRuleArray[1]["gapSize"]) || ($searchEndDateDiff >= $gapRuleArray[0]["gapSize"] && $searchEndDateDiff <= $gapRuleArray[1]["gapSize"])) {
                return true;
            }
        }
        return false;
    }

}